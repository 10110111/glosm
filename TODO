Framework
  Rendering
    * Add materials support; store vertex buffers per-material, render correspondingly; may use PolygonOffset for ordering
    * Add texture coords support (enhances materials)
    * Add shadows (stencil?) (requires materials and landuse polygons)
    * Tweak lines so they don't fill (ortho) map on low zoom levels (extra multisampling, or drawing lines in a shader?)
    * Add spherical projection
    * More solid framework for GeometryGenerator (maybe use scripting language like python)
    * Shadows
    * Switch to new OpenGL world order
      * glBegin/end/color -> glUniform
      * Fixed pipeline -> shaders
      * gl*Pointer, glClient* -> glVertexAttribPointer
  Geometry generation
    * Add lane divisors
    * Support landuse/natural polygons in geomgen - will need a large table for that, maybe geomgen should be split (requires materials)
    * Multipolygon support
    * We will probably end up with generic geometry class with support for all possible OpenGL primitives ({tri, quad} * {,strip,fan} + indexes) sorted by material (or by other properties)
    * Basic CSG - don't draw edges on flat joined walls
    * Automatic edger - takes geometry, creates edges for it, automatically removes duplicate edges and edges for flat surfaces
    * Automatic merger for flat polygons (roads)
    * Idea for another geometry generator - flat generator mimicking mapnik output
  Refactoring
    * OsmDatasource should have iterator-based interface with postgres schema in mind (are things like way-by-node possible? - required for geomgen)
    * All external interfaces (especially Viewers) should have double lot/lan/height/angle interface, not obscure internal fixed points
    * Split default geomgen into topic files (Roofs, Walls, Roads etc.)
  Documentation
    * Document most class methods and members
  New layers
    * Layer with GPX data - GpxLayer, GpxTile, GpxDatasource
    * Implement tagdict for efficient tag storage, add node tags support
  Misc
    * POVray export for geometry. Just curious what can be rendered then
  Performance
    * XML parsing takes most of time: finish libfastosm (my very fast XML parser specially for OSM) and use it
    * In geometry generation optimization focus should be optimal tags processing (std::string ops take quite a lot of time) and TranslatePoints optimization
    * Add profiling support to viewer (or separate test); FindModules for google perftools
  Tiling
    * Asynchronous tile loading
    * Don't drop invisible tiles right away, implement queue, drop LRU
    * Scale visible area dependent on height
    * Implement LOD's

Applications
  Tiler
    * Optionally, hardlink empty tiles
    * Render multiple tiles at once (e.g. 16x16)
    * Use multiple threads for png saving
    * getopt_long interface
    * Ability to render single image of arbitary size
    * Need 16x multisampling for proper eyecandy, while hardware only provides 4x. Can think of accum buffer (it's very slow, but rendering likely won't be a bottleneck anyway) or render to texture with following downscaling
    * Add jpeg saving support (more useful than png when texture support is added)
  Viewer
    * Support loading multiple .osm files (as multiple layers or as multiple tiles)
  New applications
    * Qt viewer
    * Mobile viewer
    * Geometry generator (like tiler, but for geometry)
    * Persistent app for continuos database change watching and geometry tile updating - can be a base for other services (useable client, tile rendering infrastructure)

General
  * Build viewer for maemo (or find maintainer)
  * Build viewer for windows (or find maintainer)

Infrastructure
  * Need hosting for png & geometry tiles
  * Need dedicated server with replicated database for realtime rendering
  * Maybe distributed tile rendering like Tiles@Home
  * WebGL viewer for generated portable tiles (after those are done) - as I don't have enough skill in web programming, help is needed here
